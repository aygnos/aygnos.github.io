<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Blogs on Akagi201 </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>http://akagi201.github.io/blog/index.xml</link>
    <language>en-us</language>
    
    
    <updated>Wed, 14 Jan 2015 16:02:08 CST</updated>
    
    <item>
      <title>Stream Encoder</title>
      <link>http://akagi201.github.io/blog/stream-encoder/</link>
      <pubDate>Wed, 14 Jan 2015 16:02:08 CST</pubDate>
      
      <guid>http://akagi201.github.io/blog/stream-encoder/</guid>
      <description>

&lt;h2 id=&#34;toc_0&#34;&gt;OBS&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/jp9000/obs-studio&#34;&gt;https://github.com/jp9000/obs-studio&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;开发前说明: &lt;a href=&#34;https://obsproject.com/forum/threads/getting-started-with-obs-development.21326/&#34;&gt;https://obsproject.com/forum/threads/getting-started-with-obs-development.21326/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;文档: &lt;a href=&#34;http://jp9000.github.io/OBS/&#34;&gt;http://jp9000.github.io/OBS/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;OBS core: libobs, OBS UI: obs, core跟ui是独立的.&lt;/li&gt;
&lt;li&gt;OBS core plugins: plugins&lt;/li&gt;
&lt;li&gt;IRC: #obsproject on Freenode, #obs-dev on Quakenet&lt;/li&gt;
&lt;li&gt;settings estimator: &lt;a href=&#34;https://obsproject.com/estimator&#34;&gt;https://obsproject.com/estimator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;BLE&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/wenjiegit/Bull-Live-Encoder&#34;&gt;https://github.com/wenjiegit/Bull-Live-Encoder&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Learning RTP</title>
      <link>http://akagi201.github.io/blog/learning-rtp/</link>
      <pubDate>Mon, 15 Dec 2014 21:50:26 CST</pubDate>
      
      <guid>http://akagi201.github.io/blog/learning-rtp/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://www.mindmup.com/map/b/akagi201/learning-rtp.mup&#34; data-role=&#34;mindmup-embed&#34; title=&#34;learning-rtp&#34; data-width=&#34;90%&#34; data-height=&#34;500&#34; data-style=&#34;border:1px solid black;margin-bottom:5px;&#34;&gt;learning-rtp on MindMup&lt;/a&gt;
&lt;script async src=&#34;https://www.mindmup.com/external-embed.js&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;RTP&lt;/code&gt;(Real-time Transport Protocol)是用于Internet上针对多媒体数据流的一种传输协议. &lt;code&gt;RTP&lt;/code&gt;被定义为在一对一或一对多的传输情况下工作, 其目的是提供时间信息和实现流同步. &lt;code&gt;RTP&lt;/code&gt;通常使用&lt;code&gt;UDP&lt;/code&gt;来传送数据, 但&lt;code&gt;RTP&lt;/code&gt;也可以在&lt;code&gt;TCP&lt;/code&gt;或&lt;code&gt;ATM&lt;/code&gt;等其他协议之上工作.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;RTP&lt;/code&gt;本身并没有提供按时发送机制或其他服务质量(QoS)保证, 它依赖于底层服务去实现这一过程. &lt;code&gt;RTP&lt;/code&gt;并不保证传送或防止无序传送, 也不确定底层网络的可靠性.&lt;/p&gt;

&lt;h2 id=&#34;toc_0&#34;&gt;book&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.safaribooksonline.com/library/view/rtp-audio-and/0672322498/&#34;&gt;https://www.safaribooksonline.com/library/view/rtp-audio-and/0672322498/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.com/RTP-Audio-Video-Internet-paperback/dp/0321833627&#34;&gt;http://www.amazon.com/RTP-Audio-Video-Internet-paperback/dp/0321833627&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Learning cURL</title>
      <link>http://akagi201.github.io/blog/learning-curl/</link>
      <pubDate>Tue, 09 Dec 2014 03:55:26 CST</pubDate>
      
      <guid>http://akagi201.github.io/blog/learning-curl/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://www.mindmup.com/map/b/akagi201/learning-curl.mup&#34; data-role=&#34;mindmup-embed&#34; title=&#34;learning-gtest&#34; data-width=&#34;90%&#34; data-height=&#34;500&#34; data-style=&#34;border:1px solid black;margin-bottom:5px;&#34;&gt;learning-gtest on MindMup&lt;/a&gt;
&lt;script async src=&#34;https://www.mindmup.com/external-embed.js&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;cURL全称是&amp;rdquo;Client for URLs&amp;rdquo;, 即URL客户端.&lt;/p&gt;

&lt;p&gt;是&lt;a href=&#34;https://github.com/bagder&#34;&gt;Daniel Stenberg&lt;/a&gt;的一个个人项目, 就放在个人的一个二级域名&lt;a href=&#34;http://curl.haxx.se/&#34;&gt;http://curl.haxx.se/&lt;/a&gt;下, 所以有的地方略显粗糙也可以理解了.&lt;/p&gt;

&lt;p&gt;项目历史应该比较久远了, 文档全是用的&lt;code&gt;manpage&lt;/code&gt;写的, 不用到处找了, 直接&lt;code&gt;man&lt;/code&gt;就可以了.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;curl&lt;/code&gt;的&lt;code&gt;repo&lt;/code&gt;由两部分组成, &lt;code&gt;curl&lt;/code&gt;命令行跟&lt;code&gt;libcurl&lt;/code&gt;, 其中复杂的东西都在&lt;code&gt;libcurl&lt;/code&gt;中了.&lt;/p&gt;

&lt;h2 id=&#34;toc_0&#34;&gt;源码结构&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;curl&lt;/code&gt;命令行的源码在&lt;code&gt;src/&lt;/code&gt;, 入口在&lt;code&gt;tool_main.c&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;libcurl&lt;/code&gt;的源码在&lt;code&gt;lib/&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;API example&lt;/code&gt;的源码在&lt;code&gt;docs/examples&lt;/code&gt;下.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Learning Google C&#43;&#43; Testing Framework</title>
      <link>http://akagi201.github.io/blog/learning-gtest/</link>
      <pubDate>Thu, 04 Dec 2014 21:35:26 CST</pubDate>
      
      <guid>http://akagi201.github.io/blog/learning-gtest/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.mindmup.com/map/b/akagi201/learning-gtest.mup&#34; data-role=&#34;mindmup-embed&#34; title=&#34;learning-gtest&#34; data-width=&#34;90%&#34; data-height=&#34;500&#34; data-style=&#34;border:1px solid black;margin-bottom:5px;&#34;&gt;learning-gtest on MindMup&lt;/a&gt;
&lt;script async src=&#34;https://www.mindmup.com/external-embed.js&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;最近接触不少有趣的小项目, 让我重拾C语言的乐趣了. 现在移动和web发展非常块, web领域技术的发展, 也推进了底层技术的发展. &lt;code&gt;clib&lt;/code&gt;就让我对&lt;code&gt;js&lt;/code&gt;跟&lt;code&gt;node&lt;/code&gt;这帮人的印象大大改观.&lt;/p&gt;

&lt;p&gt;跟着牛人的脚本慢慢前进是不会错的. 选择了&lt;code&gt;CLion&lt;/code&gt;, 导致选择了&lt;code&gt;CMake&lt;/code&gt;, 又由&lt;code&gt;CMake&lt;/code&gt;跟&lt;code&gt;CLion&lt;/code&gt;选择了&lt;code&gt;GTest&lt;/code&gt;. 学习下来发现都是好东西.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Google C++ Testing Framework&lt;/code&gt;简称&lt;code&gt;GTest&lt;/code&gt;, 跟&lt;code&gt;CMake&lt;/code&gt;集成的非常好, 而且他本身就是用&lt;code&gt;CMake&lt;/code&gt;编译的, 作为一个转向&lt;code&gt;CMake&lt;/code&gt;开发者来说, 这是极赞的.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;GTest&lt;/code&gt;文档相应比较少, 对于新手来说可能有点曲线, 我写了几个集成&lt;code&gt;Makefile&lt;/code&gt;跟&lt;code&gt;CMake&lt;/code&gt;的例子, 可以看看: &lt;a href=&#34;https://github.com/Akagi201/learning-gtest&#34;&gt;https://github.com/Akagi201/learning-gtest&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Learning Libuv</title>
      <link>http://akagi201.github.io/blog/learning-libuv/</link>
      <pubDate>Thu, 13 Nov 2014 01:50:26 CST</pubDate>
      
      <guid>http://akagi201.github.io/blog/learning-libuv/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.mindmup.com/map/b/akagi201/learning-libuv.mup&#34; data-role=&#34;mindmup-embed&#34; title=&#34;learning-libuv&#34; data-width=&#34;90%&#34; data-height=&#34;500&#34; data-style=&#34;border:1px solid black;margin-bottom:5px;&#34;&gt;learning-libuv on MindMup&lt;/a&gt;
&lt;script async src=&#34;https://www.mindmup.com/external-embed.js&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;想研究libuv很久了, 一直没有用他的机会, 这次项目中有个多进程管理的地方, 正纠结怎么操作麻烦的信号量时, 想起libuv也可以完成这件事, 所以, 赶紧用起来. 不用白不用.&lt;/p&gt;

&lt;p&gt;Lua在嵌入式领域大有可以, 可以编译成一个liblua.a的库静态连接到C程序, 还有很多丰富的工具, 本身语言有非常小巧, 以后还是多用lua写写, 方便移植啊. 多平台各种差异, 搞死人啊.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Learning uC/OS</title>
      <link>http://akagi201.github.io/blog/learning-ucos/</link>
      <pubDate>Thu, 13 Nov 2014 01:28:26 CST</pubDate>
      
      <guid>http://akagi201.github.io/blog/learning-ucos/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.mindmup.com/map/b/akagi201/learning-ucos.mup&#34; data-role=&#34;mindmup-embed&#34; title=&#34;learning-ucos&#34; data-width=&#34;90%&#34; data-height=&#34;500&#34; data-style=&#34;border:1px solid black;margin-bottom:5px;&#34;&gt;learning-ucos on MindMup&lt;/a&gt;
&lt;script async src=&#34;https://www.mindmup.com/external-embed.js&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;最近比较粗略的学习了一下uC/OS-II的系统, 感觉设计上中规中矩吧, 很多类似的结构, 应该可以设计得更精简些的, 不过, 在单片机系统上用的还是蛮多的. 其中任务就绪表跟内存管理部分, 还需要有空再详细看看.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>About Blog</title>
      <link>http://akagi201.github.io/blog/about-blog/</link>
      <pubDate>Tue, 21 Oct 2014 02:53:26 CST</pubDate>
      
      <guid>http://akagi201.github.io/blog/about-blog/</guid>
      <description>

&lt;h2 id=&#34;toc_0&#34;&gt;TODO&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;在slide部分上方显示我的头像.&lt;/li&gt;
&lt;li&gt;在手机跟PC上显示slide部分更优雅一点.&lt;/li&gt;
&lt;li&gt;中英文两个版本切换.&lt;/li&gt;
&lt;li&gt;不同分类用不同的样式.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Categories&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;blog, tool, book, talk, project&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Tags&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;openwrt, kernel, wifi, hardware, macosx, golang, algorithm, git, protocol, security&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Markdown Contents&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Akagi201/akblog&#34;&gt;https://github.com/Akagi201/akblog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Static Pages&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Akagi201/akagi201.github.io&#34;&gt;https://github.com/Akagi201/akagi201.github.io&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Learning CMake</title>
      <link>http://akagi201.github.io/blog/learning-cmake/</link>
      <pubDate>Sun, 19 Oct 2014 00:35:26 CST</pubDate>
      
      <guid>http://akagi201.github.io/blog/learning-cmake/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://www.mindmup.com/map/b/akagi201/learning%20cmake.mup&#34; data-role=&#34;mindmup-embed&#34; title=&#34;learning cmake&#34; data-width=&#34;90%&#34; data-height=&#34;500&#34; data-style=&#34;border:1px solid black;margin-bottom:5px;&#34;&gt;learning cmake on MindMup&lt;/a&gt;
&lt;script async src=&#34;https://www.mindmup.com/external-embed.js&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;为了更好的掌握CLion, 最近把CMake Practice看完, 并练习了一下. 完成之后发现内容很少. 老的autotools也是要掌握的, openwrt上编译很多项目还是要用到他.&lt;/p&gt;

&lt;h2 id=&#34;toc_0&#34;&gt;Github Repo&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Akagi201/learning-cmake&#34;&gt;https://github.com/Akagi201/learning-cmake&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Learning FFmpeg</title>
      <link>http://akagi201.github.io/blog/learning-ffmpeg/</link>
      <pubDate>Fri, 10 Oct 2014 10:31:26 CST</pubDate>
      
      <guid>http://akagi201.github.io/blog/learning-ffmpeg/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.mindmup.com/map/b/akagi201/learning%20ffmpeg.mup&#34; data-role=&#34;mindmup-embed&#34; title=&#34;learning ffmpeg&#34; data-width=&#34;90%&#34; data-height=&#34;500&#34; data-style=&#34;border:1px solid black;margin-bottom:5px;&#34;&gt;learning ffmpeg on MindMup&lt;/a&gt;
&lt;script async src=&#34;https://www.mindmup.com/external-embed.js&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;我自己购买了mindmup gold的账号, 有钱淫欢迎投资我啊!!&lt;/p&gt;

&lt;p&gt;发现个ffmpeg领域的大牛, 他已经在读博士了, 天朝这样做学术的人还是值得赞赏的, ffmpeg中文资料必看: &lt;a href=&#34;http://blog.csdn.net/leixiaohua1020&#34;&gt;http://blog.csdn.net/leixiaohua1020&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Learning Network</title>
      <link>http://akagi201.github.io/blog/learning-network/</link>
      <pubDate>Wed, 17 Sep 2014 15:28:26 CST</pubDate>
      
      <guid>http://akagi201.github.io/blog/learning-network/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://www.mindmup.com/map/a1463fc090205c0132ece74a07efcd9b01&#34; data-role=&#34;mindmup-embed&#34; title=&#34;Introduction to Computer Networks&#34; data-width=&#34;90%&#34; data-height=&#34;500&#34; data-style=&#34;border:1px solid black;margin-bottom:5px;&#34;&gt;Introduction to Computer Networks on MindMup&lt;/a&gt;
&lt;script async src=&#34;https://www.mindmup.com/external-embed.js&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;h2 id=&#34;toc_0&#34;&gt;Google Drive&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;mindmup 免费的在线分享放不下了, 只能放到google drive上了.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://drive.google.com/file/d/0BzJcP7mynkO5aVIyRlg4X0xxYlU/view?usp=sharing&#34;&gt;https://drive.google.com/file/d/0BzJcP7mynkO5aVIyRlg4X0xxYlU/view?usp=sharing&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Streaming Protocols</title>
      <link>http://akagi201.github.io/blog/streaming-protocols/</link>
      <pubDate>Tue, 09 Sep 2014 15:28:26 CST</pubDate>
      
      <guid>http://akagi201.github.io/blog/streaming-protocols/</guid>
      <description>&lt;p&gt;整理了一下流媒体相关的协议, 可能部分划分的不科学, 展开的不够细致. 先分享出来好了.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.mindmup.com/map/a1ec1c10f01a470132be43265f407368e9&#34; data-role=&#34;mindmup-embed&#34; title=&#34;streaming protocols&#34; data-width=&#34;90%&#34; data-height=&#34;500&#34; data-style=&#34;border:1px solid black;margin-bottom:5px;&#34;&gt;streaming protocols on MindMup&lt;/a&gt;
&lt;script async src=&#34;https://www.mindmup.com/external-embed.js&#34;&gt;&lt;/script&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Learning OpenWrt - Outline</title>
      <link>http://akagi201.github.io/blog/learning-openwrt/</link>
      <pubDate>Mon, 25 Aug 2014 03:02:26 CST</pubDate>
      
      <guid>http://akagi201.github.io/blog/learning-openwrt/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.mindmup.com/map/a1a4fe3d700e3201320be50ecffad778f1&#34; data-role=&#34;mindmup-embed&#34; title=&#34;Learning OpenWrt&#34; data-width=&#34;90%&#34; data-height=&#34;500&#34; data-style=&#34;border:1px solid black;margin-bottom:5px;&#34;&gt;Learning OpenWrt on MindMup&lt;/a&gt;
&lt;script async src=&#34;https://www.mindmup.com/external-embed.js&#34;&gt;&lt;/script&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>FreeRADIUS新手入门 - 我翻译的开源书</title>
      <link>http://akagi201.github.io/blog/freeradius-beginners-guide/</link>
      <pubDate>Fri, 22 Aug 2014 13:35:26 CST</pubDate>
      
      <guid>http://akagi201.github.io/blog/freeradius-beginners-guide/</guid>
      <description>

&lt;p&gt;最近在搭建CoovaChilli + FreeRadius的认证系统. 顺便把一本英文书翻译一下. 由于时间比较匆忙, 所以还不保证质量, 想尽快翻译完, 然后在慢慢斟酌个别语句. 这个项目本身也是试水作品, 为以后写自己的书做些&lt;strong&gt;技术储备&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;在写书的过程中发现几个问题:
* gitbook中文支持有写问题, 有时候文本最左边字会叠在一起.
* 有时候gitbook会崩溃, 有时候搜狗输入法会比较卡, 不知道是否是兼容性问题, 要及时保存.
* 原文章节层次结构太乱了, 只有一级跟二级标题, 三级标题, 四级标题跟二级标题字体样式完全一样, 没法区分, 抽空要整理下.
* markdown感觉层次太多的时候会记不住自己在哪层了.
* github还没同步过来, 国内用gitbook写书的还不多, 问了一圈没得到答复.&lt;/p&gt;

&lt;h2 id=&#34;toc_0&#34;&gt;在线阅读地址&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://freeradius.akagi201.org&#34;&gt;http://freeradius.akagi201.org&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;github地址(还没同步过来, 求助)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Akagi201/freeradius-beginners-guide&#34;&gt;https://github.com/Akagi201/freeradius-beginners-guide&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>将OpenWrt变成完美的BSP</title>
      <link>http://akagi201.github.io/blog/turn-openwrt-into-the-perfect-bsp/</link>
      <pubDate>Thu, 03 Jul 2014 12:26:26 CST</pubDate>
      
      <guid>http://akagi201.github.io/blog/turn-openwrt-into-the-perfect-bsp/</guid>
      <description>

&lt;p&gt;BSP(Board Support Package)对于嵌入式开发者一定不陌生, 就是针对一种板子适配指定的操作系统(常见的是linux)所需要的bootloader, 板上外设的所有驱动, 还有内核, 通常还包括一个根文件系统(里面包含能确保板子能跑起来的基本的一些配置)和toolchain.&lt;/p&gt;

&lt;p&gt;随着软件系统的发展, 越来越多的统一化环境配置的工具出现, 像vagrant, docker等, 这样, 将运行环境一起打包就不会出现过去那种, 在我的机器上能运行, 在你的机器上运行不了的情况了.&lt;/p&gt;

&lt;p&gt;嵌入式开发也是一样, 每次面对一种新的SOC, 多要进行一些重复工作, 像裁剪系统, 裁剪busybox, 移植各种应用, 各种库等. 对于开发而言, 对于每种平台开发时, 都要有一些细小的差异. 而这些差异是可以统一起来的. 解决方案就是OpenWrt.&lt;/p&gt;

&lt;p&gt;用OpenWrt作为BSP, 这使得用户和开发者可以快速熟悉不同的/新的硬件产品. 关于OpenWrt的详细内容, 在OpenWrt的官方文档有非常详细的介绍. &lt;a href=&#34;http://wiki.openwrt.org/doc/start&#34;&gt;http://wiki.openwrt.org/doc/start&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;那么公司如何用OpenWrt做自己的产品呢? 根据开源项目的特点需要进行一些修改.&lt;/p&gt;

&lt;h2 id=&#34;toc_0&#34;&gt;OpenWrt Buildroot的Makefile wrapper&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;download tool: 下载指定版本的OpenWrt&lt;/li&gt;
&lt;li&gt;patchset: 对指定版本的OpenWrt进行打补丁, 确保稳定&lt;/li&gt;
&lt;li&gt;package feed: 自己软件包的 package feed.&lt;/li&gt;
&lt;li&gt;dl link directory: 将~/dl链接到openwrt/dl.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;使用OpenWrt buildroot过程的技巧&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;OpenWrt的buildroot编译系统, 包含fetching, patching, compiling, packaging的过程. 在fetching阶段会联网下载源码到dl目录, 所以, 一个好的方法是, 将dl目录保存在自己本地机器的一个固定位置, 然后软链接到openwrt/dl目录, 这样就不用每次下载重复的包了, 另外, 有时由于网络原因, 可以手动下载包放到这个目录.&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>地理围栏(Geo-fencing)</title>
      <link>http://akagi201.github.io/blog/geo-fencing/</link>
      <pubDate>Thu, 26 Jun 2014 02:21:26 CST</pubDate>
      
      <guid>http://akagi201.github.io/blog/geo-fencing/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/geofencing.png&#34; alt=&#34;geofencing&#34; /&gt;
&lt;/p&gt;

&lt;h2 id=&#34;toc_0&#34;&gt;Geo-fencing&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;A geo-fence is a virtual perimeter for a real-world geographic area.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Geo-fence&#34;&gt;http://en.wikipedia.org/wiki/Geo-fence&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;地理围栏(Geo-fencing)是LBS的一种新应用, 就是用一个虚拟的栅栏围出一个虚拟地理边界. 当手机进入, 离开某个特定地理区域, 或在该区域内活动时, 手机可以接收自动通知和警告.&lt;/li&gt;
&lt;li&gt;有了地理围栏技术, 位置社交网站就可以帮助用户在进入某一地区时自动登记, 可应用智能购物, 个人助理, 家庭成员/朋友的发现, 智能家居等领域.&lt;/li&gt;
&lt;li&gt;地理围栏可通过蓝牙, WIFI, GPS等定位技术完成, 移动设备进入围栏后会自动选择最低功耗方式进行定位, 地理围栏技术为开发者提供全新想象空间.&lt;/li&gt;
&lt;li&gt;地理围栏技术均是: 预先划定一些多边形的区域, 一个中心化的设备或者云端知道定位源进入该区域; 定位源知道自己进入该区域; 触发一些响应, 例如消息的push. 在智能硬件时代, 这种能够更加精准地定位, 更加节省功耗, 更加有效率低成本的互联互通方式, 迎来爆发机会.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Geo-fencing vs LBS&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;地理围栏的地理区域是被网格化的. 网格化的标准是根据一个地理区域内的业务和商业聚类的, 而不是纯粹的经纬度和城市地图的匹配.&lt;/li&gt;
&lt;li&gt;实际上地理围栏的各个围栏的区隔是一个个的应用需求群地图. 主要的商业需求聚集在特定区域, 形成的一个聚合信息服务区域.&lt;/li&gt;
&lt;li&gt;终端自己或者在网络帮助下能够识别所处的围栏.&lt;/li&gt;
&lt;li&gt;用户的围栏信息彼此之间能够共享, 也能够与应用开发商分享.&lt;/li&gt;
&lt;li&gt;双向, 互动是关键.&lt;/li&gt;
&lt;li&gt;商业群落是地理围栏的核心, 类似城市的商圈.&lt;/li&gt;
&lt;li&gt;价值整合, 场景整合, 信息流资金流整合是关键.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Geo-fencing vs Beacons&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://mashable.com/2014/02/24/beacons-geofencing-location/&#34;&gt;http://mashable.com/2014/02/24/beacons-geofencing-location/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.mobizou.com/geolocation-privacy-gaining-steam/&#34;&gt;http://www.mobizou.com/geolocation-privacy-gaining-steam/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Geo-fencing Applications&lt;/h2&gt;

&lt;h3 id=&#34;toc_4&#34;&gt;百度的地理围栏技术&lt;/h3&gt;

&lt;p&gt;百度地理围栏技术是国内首家提供离线+在线地理围栏服务的产品, 基于位置的提醒和离在线结合的方式, 实现了功耗的大幅降低. 用户离关键位置点较远的时候, 会进行距离判断, 在用户到达围栏周围的时候, 再请求在线定位, 询问用户是否触发围栏.由于用户不需要一直打开GPS, 所以在使用该功能时达到了省流量, 省电的目的.&lt;/p&gt;

&lt;p&gt;百度地理围栏技术&amp;rdquo;离线+在线&amp;rdquo;的技术策略, 能够让在用户体验上更为顺畅, 摆脱网络状况的限制, 避免智能手机普遍待机时间短的缺点, 极大提升了地理围栏的工作效率, 因此使用百度定位SDK提供的地理围栏服务的开发者能够设计开发更适合用户需求的产品. 目前, 已经有大量开发者利用百度地理围栏SDK开发相关应用, 精彩创意层出不穷.&lt;/p&gt;

&lt;h3 id=&#34;toc_5&#34;&gt;Intel的地理围栏技术&lt;/h3&gt;

&lt;p&gt;Intel的地理围栏技术采用了有效地将地理信息整合到移动平台的应用中去, 极大提高应用的易用性, 同时权衡系统待机时间与响应时间是Intel地理围栏的关键亮点, 实现了低功耗, 快速响应和高精度三者的完美结合, 其围栏技术的创新点:&lt;/p&gt;

&lt;p&gt;1）使用MCU完成连续监测功能.&lt;/p&gt;

&lt;p&gt;2）基于情境自动甑选合理的位置提供模块.&lt;/p&gt;

&lt;p&gt;3）通过传感器轨迹推算实现实时定位和矫正.&lt;/p&gt;

&lt;p&gt;Intel地理围栏技术亮点包括:&lt;/p&gt;

&lt;p&gt;1）多定位源GNSS/Modem/WiFi.&lt;/p&gt;

&lt;p&gt;2）传感器轨迹推算.&lt;/p&gt;

&lt;p&gt;3）多地理围栏.&lt;/p&gt;

&lt;p&gt;4）情境感知.&lt;/p&gt;

&lt;p&gt;5）自适应.&lt;/p&gt;

&lt;h3 id=&#34;toc_6&#34;&gt;Apple的地理围栏 - iBeacons技术&lt;/h3&gt;

&lt;p&gt;iBeacon的出现让地理定位能够更加精确——从几百米的精度提高到了一米甚至半米. 这个精细度非常高的地理围栏, 终于可以让很多的实际物体都有条件具有了定义自己地理位置标识的能力, 例如一张桌子, 一把椅子, 都可以有自己的地理坐标.&lt;/p&gt;

&lt;p&gt;苹果在iOS 7中推出的iBeacon协议包含两个部分:&lt;/p&gt;

&lt;p&gt;1）按照苹果对iBeacon发射设备的数据流格式, 定制蓝牙设备广播, 那么这台低功耗蓝牙设备就可以被识别为iBeacon协议发射装置.&lt;/p&gt;

&lt;p&gt;2）利用iOS设备对蓝牙的广播发出设备进行判断, 如果其发出的广播数据符合iBeacon的协议, 那么就认为这台低功耗蓝牙的发射装置是一台iBeacon基站.&lt;/p&gt;

&lt;p&gt;由于iBeacon建立在蓝牙协议的基础上, 所以这个技术天然拥有了两个优势:&lt;/p&gt;

&lt;p&gt;1）硬件的无缝过渡, 不需要硬件厂商投入成本进行完全不同的硬件开发.&lt;/p&gt;

&lt;p&gt;2）现有数据传输协议对于用户来说没有太大迁移成本, 完全有能力像智能路由(Wi-Fi协议)一样成为物联网的数据中心节点.&lt;/p&gt;

&lt;h3 id=&#34;toc_7&#34;&gt;其他的地理围栏技术&lt;/h3&gt;

&lt;p&gt;地理围栏技术在10年前便已出现. 在去年的Google IO大会上便已经有了地理围栏的展览.&lt;/p&gt;

&lt;p&gt;Meridian平台便提供Zones地理围栏功能, 这项功能允许用户在开发者推出的室内地图App上随意用多边形圈区域, 而当用户真正到达这些区域时, app会立马推送通知. 除了Meridian, 国外还有几家地理围栏平台, 比如PlaceCast, Digby Localpoint, Wifarer和ShopKick. 和上述几家最大的不同是, Meridian是通过Wifi传感而非GPS定位.&lt;/p&gt;

&lt;p&gt;而Google Lititude API也支持开发者在地图上标记多边形的围栏区域, App进入该趋于时便会收到push消息. 与iBeacons等技术不同的是, 这个push消息不是由基站发送, 而是云端推动的. 跟百度地图的地理围栏技术有些相似.&lt;/p&gt;

&lt;h2 id=&#34;toc_8&#34;&gt;Refs&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.leikeji.com/thread-546-1-1.html&#34;&gt;http://www.leikeji.com/thread-546-1-1.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>